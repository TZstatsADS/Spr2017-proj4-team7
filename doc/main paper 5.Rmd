---
title: "Main paper5"
author: "Yifei Lin"
date: "April 13, 2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Step 3: Implement Paper 5

**Brief Description of the Paper**
The paper 5 use error driven machine learning algorithm under different loss functions. We complete the C/E/Pr algorithm, which is Clusterwise, Error-driven Online Training. In our algorithm, we use the K-means as our basic cluster method. The main advantage of K-means is that it have a continuous score function. And in the Error-driven Online Training, we update the parameters when we find the first error. 

**Feature Creation**
Source function from lib
```{r}
source("../lib/lyf_helper.R")
source("../lib/feature_helper.R")
```

Alter all text files into proper format in order to produce features
```{r}
data.lib="../data/nameset"
data.files=list.files(path=data.lib, "*.txt")
query.list=substring(data.files, 
                     1, nchar(data.files)-4)
query.list=paste(substring(query.list, 1, 1), 
                 " ", 
                 substring(query.list, 
                           2, nchar(query.list)),
                 sep=""
                 )
data_list=list(1:length(data.files))
for(i in 1:length(data.files)){
  dat=as.list(readLines(paste(data.lib, data.files[i], sep="/")))
  data_list[[i]]=lapply(dat, f.line.proc, nam.query=query.list[i])
}
```

Generate Features:

f.coauthor (function): takes the name of author as input and generate coauthor features. Specifically, each row is a record and each column is a coauthor. If one record contains one coauthor, the corresponding value is 1. Otherwise, it is 0. Furthermore, we eliminate coauthor who only appears once in the date set.
f.journal (function): takes the name of author as input and generate journal features. Specifically, each row is a record and each column is a journal. If one record contains one journal, the corresponding value is 1. Otherwise, it is 0. Furthermore, we eliminate journal that only appears once in the date set.
f.ptitle (function): takes the name of author as input and generate paper title features. Specifically, each row is a record and each column is a key word. 
```{r}
feature <- list()

for (j in 1:14) {
authorid<- c()
for (i in 1:length(data_list[[j]])) {
  authorid[i] <- data_list[[j]][[i]][1]
}
authorid<-unlist(authorid)
paperid<-c()
for (i in 1:length(data_list[[j]])) {
  paperid[i] <- data_list[[j]][[i]][2]
}
paperid<-unlist(paperid)
authorname<- query.list[j]
feature[[j]]<- cbind(authorid,paperid,authorname,f.coauthor(authorname),f.journal(authorname), f.ptitle(authorname))

}
#save(feature,file="../output/feature.Rdata")
```

**Model**
##K-means
```{r}

update1<-function(mu1,mu2,a){
  d<-abs(mu2-mu1)
  a<-a*(1+d/sum(d))
  return(a)
}
update2<-function(mu.t,mu.f,err,a){
  d.t<-abs(mu.t-err)+1
  d.f<-abs(mu.f-err)+1
  a<-a*(d.f/d.t)
  return(a)
}

dist<-function(a1,a2,l){
    n<-length(a1)
    x<-(a1-a2)^2
    x<-l*x
    return(sum(x))
  }



train<-function(df){
  y<-df[,1]
  df<-df[,-1:-3]
  df<-matrix(unlist(df),nrow(df),ncol(df))
  
  l<-levels(factor(y))
  K<-length(l)
  max.iteration<-10
  d<-ncol(df)
  lambda<-rep(0,d)
  lambda.new<-rep(1,d)
  weight<-rep(1,d)
  j<-0
  
  cluster<-list()
  u<-list()
  first_point<-function(t){
    return(t[1])
  }
  d<-tapply(1:nrow(df),y,first_point)
  for(i in 1:K){
    cluster[[i]]<-c(d[i])
    u[[i]]<-df[d[i],]
    #u[[i]]<-unlist(df[d[i],-c(1,2,3)])
  }
  l<-y[d]
  
  while (dist(lambda,lambda.new,weight)>0.01 & j<=max.iteration){
    j<-j+1
    lambda<-lambda.new
    for (i in 1:nrow(df)){
      distance<-c()
      for (k in 1:K){
        distance<-c(distance,dist(df[i,],u[[k]],lambda.new))
        #distance<-c(distance,dist(unlist(df[i,-c(1,2,3)]),u[[k]],lambda.new))
      }
      m<-which.min(distance)
      r<-which(l==y[i])
      if (m!=r){
        #lambda.new<-update1(u[[r]],u[[m]],lambda.new)
        lambda.new<-update2(u[[r]],u[[m]],df[i,],lambda)
        m<-r
      }
      cluster[[m]]<-c(cluster[[m]],i)
      u[[m]]<-colMeans(df[cluster[[m]],])
    }
  }
  
  u2<-unlist(u[[1]])
  for (s in 2:K){
    u2<-rbind(u2,unlist(u[[s]]))
  }
  
  return(list(lambda=lambda.new,K,label=y,center=u2,iteration=j))
  
}


test2<-function(df,lambda){
  y<-df[,1]
  k<-length(unique(y))
  df<-df[,-1:-3]
  df<-matrix(unlist(df),nrow(df),ncol(df))
  km_new<-function(x,a,k){
  for(i in 1:ncol(x)){
    x[,i]<-x[,i]*sqrt(a[i])
  }
  cl<-kmeans(x,k)
  return(cl)
}
  y2<-km_new(df,lambda,k)
  
  cluster<-function(x){
    return(length(x)-max(table(x)))
  }
  
  error<-tapply(y,y2$cluster,cluster)
  return(list(y2$cluster,y,accuracy=(length(y)-sum(error))/length(y)))
}

# result<-test(f2,flambda$lambda,flambda[[2]],flambda$label,flambda$center)
# result2<-test(f1,flambda$lambda,flambda[[2]],flambda$label,flambda$center)
re<-test2(f2,flambda$lambda)

```


**evaluation:error and running time**

```{r}
load(file="../output/feature.Rdata")
time<-c()
accuracy<-c()

for(i in 8:14){
  f1<-feature[[i]]
  te<-sample(1:nrow(f1),100,replace = TRUE)
  f2<-f1[te,]
  #f1<-f1[-te,]
  t1<-Sys.time()
  flambda<-train(f1)
  t2<-Sys.time()
  time<-c(time,t2-t1)
  re<-test2(f2,flambda$lambda)
  accuracy<-c(accuracy,re$accuracy)
}

```
